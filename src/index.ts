import { Project } from 'ts-morph';
import crypto from 'crypto';
import fs from 'fs';
import path from 'path';

export interface DupGroup {
  similarity: number;
  types: { file: string; name: string }[];
}
export interface DryOptions {
  threshold?: number; // similarity 0â€‘1
  json?: boolean;
  fix?: boolean;
  outFile?: string;
}

export function findDuplicateTypes(projectPath: string, opts: DryOptions = {}) {
  const { threshold = 1, json = false, fix = false, outFile } = opts;
  const project = new Project({ tsConfigFilePath: path.join(projectPath, 'tsconfig.json') });

  // 1) Collect declarations
  const buckets = collect(project);
  // 2) Compare for duplicates
  const groups = buildGroups(buckets, threshold);

  // 3) Report
  if (json) {
    const out = JSON.stringify(groups, null, 2);
    outFile ? fs.writeFileSync(outFile, out) : console.log(out);
  } else {
    groups.forEach(report);
  }

  // 4) Optional fix file (exact matches only)
  if (fix) writeFixFile(groups, projectPath, outFile ?? path.join(projectPath, 'duplicates.ts'));

  return groups;
}

function collect(project: Project) {
  const map = new Map<string, { text: string; locations: { file: string; name: string }[] }>();
  project.getSourceFiles().forEach(sf => {
    [...sf.getInterfaces(), ...sf.getTypeAliases()].forEach(decl => {
      const text = decl
        .getText()
        .replace(/^(export\s+)?(interface|type)\s+\w+/, '')
        .replace(/\s+/g, ' ')
        .trim();
      const hash = sha(text);
      if (!map.has(hash)) map.set(hash, { text, locations: [] });
      map.get(hash)!.locations.push({ file: sf.getFilePath(), name: decl.getName() });
    });
  });
  return [...map.values()];
}

function buildGroups(
  buckets: { locations: { file: string; name: string }[]; text: string }[],
  threshold: number
) {
  const groups: DupGroup[] = [];

  for (const b of buckets) {
    if (b.locations.length > 1) {
      groups.push({ similarity: 1, types: b.locations });
    }
  }

  for (let i = 0; i < buckets.length; i++) {
    for (let j = i + 1; j < buckets.length; j++) {
      const sim = jaccard(sha(buckets[i].text), sha(buckets[j].text));
      if (sim >= threshold) {
        groups.push({ similarity: sim, types: [...buckets[i].locations, ...buckets[j].locations] });
      }
    }
  }
  return groups;
}

function writeFixFile(groups: DupGroup[], root: string, out: string) {
  const exact = groups.filter(g => g.similarity === 1);
  if (!exact.length) return;
  let body = '// Autoâ€‘generated by typescriptâ€‘dry â€“ identical types unified\n\n';
  exact.forEach((g, idx) => {
    const base = g.types[0];
    body += `// Group ${idx + 1}\nexport type ${base.name} = {/* replace with real shape */};\n`;
    g.types.slice(1).forEach(t => (body += `export type ${t.name} = ${base.name};\n`));
    body += '\n';
  });
  fs.writeFileSync(out, body);
  console.log(`ðŸ› ï¸  duplicates.ts written â†’ ${path.relative(root, out)}`);
}

function report(g: DupGroup) {
  console.log(`ðŸ§© ${Math.round(g.similarity * 100)}% similar`);
  g.types.forEach(t => console.log('   ', `${t.file}:${t.name}`));
  console.log();
}

function sha(s: string) {
  return crypto.createHash('sha1').update(s).digest('hex');
}
function jaccard(a: string, b: string) {
  const A = new Set(a),
    B = new Set(b);
  const inter = [...A].filter(x => B.has(x)).length;
  return inter / (A.size + B.size - inter);
}
